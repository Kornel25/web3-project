import pkg from 'discord.js';
const { Client, GatewayIntentBits, MessageAttachment } = pkg
import fs from 'fs';
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions,
  ]
});

const bannedWords = [
  // Insultes et gros mots généraux (français et anglais)
  'connard', 'connasse', 'enculé', 'salope', 'pute', 'pédé', 'nique ta mère', 'nique ton père', 'poufiasse', 
  'bouffon', 'fils de pute', 'trou du cul', 'enfoiré', 'batard', 'gouine', 'tapette', 'clochard', 'branleur', 
  'branleuse', 'va te faire foutre', 'je t’emmerde','emmerdeur', 'racaille', 
  'pute à clic', 'bordel', 'pisseuse', 'ducon', 'pédale', 'pétasse', 'pouffiasse', 'dégénéré', 'crevure',
  'fuck', 'fucker', 'motherfucker', 'asshole', 'bitch', 'cunt', 'dickhead', 'bastard', 'whore', 'slut', 'cock', 
  'fucking', 'shithead', 'cocksucker', 'arsehole', 'pussy', 'dildo', 'blowjob', 'cum', 'clit', 'prick', 'boobs', 
  'nipples', 'penis', 'vagina',

  // Termes discriminatoires racistes, homophobes, et xénophobes (français et anglais)
  'nigger', 'nigga', 'faggot', 'spic', 'chink', 'kike', 'wop', 'dyke', 'tranny', 'retard', 'pédophile', 'pédé', 
  'singe', 'bougnoule', 'négro', 'tête de nègre', 'youpin', 'raton', 'romanichel', 'mangeur de chien', 'face de citron', 
  'niakoué', 'portos', 'chinetoque', 'roumain', 'esquimau', 'féménazie', 'kraut', 'japs', 'bouffeur de curry', 
  'blédard', 'bougnoul', 'racaille', 'sale étranger', 'sale migrant', 'sale arabe', 'bouffeur de pastèque', 
  'bicot', 'goudou', 'camé', 'camée', 'schizo', 'mongolien', 'mongol', 'zinzin', 'esclave', 'pirate somalien', 
  'sans-papiers', 'foutue lesbienne', 'tarlouze', 'lopette', 'queer', 'freak', 'tafiole', 'chacal', 'arabe', 
  'clodo', 'caillera', 'zigoto', 'fripouille','juif',

  // Variations pour éviter les contournements (avec des caractères spéciaux et majuscules)
  'p€d€', 'n!gga', 'f@ggot', 'c*nnard', 'a$$hole', 'fûck', 'wh0re', 'sl*t', 'k!ke', 'dyk€', 'p*ssy', 'bi©ot', 'ch!nk',
  'r€tard', 's@lope', 'conn@rd', 'b@stard', 'g0ud0u', 'pédo', 'nég*o', 'j*p', 'queer'
];
const roleId = '1303363053265358848'; // Remplacez par l'ID du rôle que vous voulez attribuer
const muteRoleId = '1303357793398423593'; // Remplacez par l'ID du rôle de mute
const pollDuration = 60000; // Durée du sondage en millisecondes (ici 1 minute)
const linkRegex = /(https?:\/\/[^\s]+)/g; // Expression régulière pour détecter les liens
const imageRegex = /\.(jpeg|jpg|gif|png)$/i; // Expression régulière pour détecter les images
const rulesChannelName = 'chartes-et-regles'; // Nom du canal des règles
const rulesMessageId = '1303374683739131987'; // Remplacez par l'ID du message des règles
const infractionLimit = 3; // Limite d'infractions avant mute
const muteDuration = 60000; // Durée du mute en millisecondes (ici 1 minute)

let config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

const userInfractions = new Map();

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});

client.on('guildMemberAdd', member => {
  const role = member.guild.roles.cache.get(roleId);
  if (role) {
    member.roles.add(role).catch(console.error);
  }

  const welcomeChannel = member.guild.channels.cache.find(channel => channel.name === 'bienvenue');
  if (welcomeChannel) {
    welcomeChannel.send(`Bienvenue sur le serveur, ${member}!`).catch(console.error);
  }
});

client.on('messageCreate', message => {
  if (message.author.bot) return;

  const messageContent = message.content.toLowerCase();
  let infraction = false;

  for (const word of bannedWords) {
    if (messageContent.includes(word)) {
      message.delete().catch(console.error);
      message.channel.send(`${message.author}, ce mot est interdit !`).then(msg => {
        setTimeout(() => msg.delete(), 5000);
      }).catch(console.error);

      logModerationAction(message.guild, `${message.author.tag} a utilisé un mot interdit : ${word}`);
      infraction = true;
      break;
    }
  }
/*
  if (linkRegex.test(messageContent) || imageRegex.test(messageContent)) {
    message.delete().catch(console.error);
    message.channel.send(`${message.author}, les liens et les images ne sont pas autorisés !`).then(msg => {
      setTimeout(() => msg.delete(), 5000);
    }).catch(console.error);

    logModerationAction(message.guild, `${message.author.tag} a posté un lien ou une image.`);
    infraction = true;
  }
  */

  if (infraction) {
    const userId = message.author.id;
    if (!userInfractions.has(userId)) {
      userInfractions.set(userId, 0);
    }
    userInfractions.set(userId, userInfractions.get(userId) + 1);

    if (userInfractions.get(userId) >= infractionLimit) {
      const muteRole = message.guild.roles.cache.get(muteRoleId);
      if (muteRole) {
        const member = message.member;
        const oldRoles = member.roles.cache.filter(role => role.id !== message.guild.id);

        member.roles.remove(oldRoles).catch(console.error);
        member.roles.add(muteRole).catch(console.error);
        message.channel.send(`${message.author} a été mute pour 1 minute pour avoir enfreint les règles à plusieurs reprises.`);

        setTimeout(() => {
          member.roles.remove(muteRole).catch(console.error);
          member.roles.add(oldRoles).catch(console.error);
          message.channel.send(`${message.author} n'est plus mute.`);
        }, muteDuration);

        userInfractions.set(userId, 0); // Réinitialiser les infractions après le mute
      }
    }
  }

  if(message.content.startsWith('hi')){
  message.channel.send('HITLERRRR !!!');
  const attachment = new MessageAttachment('./htler.png'); // Remplacez 'htler.png' par le nom de votre fichier image
  message.channel.send({ files: [attachment] });
}

  if (message.content.startsWith('!setlogchannel')) {
    if (!message.member.permissions.has('ADMINISTRATOR')) {
      message.channel.send('Vous n\'avez pas la permission de définir le canal de log.');
      return;
    }

    const args = message.content.split(' ').slice(1);
    if (args.length === 0) {
      message.channel.send('Veuillez fournir le nom du canal de log.');
      return;
    }

    const newLogChannelName = args.join(' ');
    const guildId = message.guild.id;
    if (!config[guildId]) {
      config[guildId] = {};
    }
    config[guildId].logChannelName = newLogChannelName;
    fs.writeFileSync('config.json', JSON.stringify(config, null, 2));
    message.channel.send(`Le canal de log a été défini sur ${newLogChannelName}.`);
  }
});

client.on('messageReactionAdd', (reaction, user) => {
  if (reaction.message.id === rulesMessageId && reaction.message.channel.name === rulesChannelName) {
    const member = reaction.message.guild.members.cache.get(user.id);
    const accessRole = reaction.message.guild.roles.cache.get(roleId);
    if (accessRole && member) {
      member.roles.add(accessRole).catch(console.error);
    }
  }
});

function logModerationAction(guild, action) {
  const guildId = guild.id;
  const logChannelName = config[guildId] ? config[guildId].logChannelName : 'modération';
  const logChannel = guild.channels.cache.find(channel => channel.name === logChannelName);
  if (logChannel) {
    logChannel.send(action).catch(console.error);
  }
}

client.login('MTI5ODI3ODYzMjA2MTQwMzIxNg.GKPJ9p.nlnrXwUCAHnbdVULSG7X0r32bqfNsIc_Wn8OPI'); // Remplacez par le token de votre bot